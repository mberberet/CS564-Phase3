#include "heapfile.h"
#include "error.h"

//Remove later
#include "stdio.h"

//TODO Input validation, Use of dirtyPageFlag

// routine to create a heapfile
/* This function creates an empty (well, almost empty) heap file. To do this create a db level
file by calling db->createfile(). Then, allocate an empty page by invoking bm->allocPage()
appropriately. As you know allocPage() will return a pointer to an empty page in the buffer
pool along with the page number of the page. Take the Page* pointer returned from allocPage()
and cast it to a FileHdrPage*. Using this pointer initialize the values in the header page.
Then make a second call to bm->allocPage(). This page will be the first data page of the
file. Using the Page* pointer returned, invoke its init() method to initialize the page
contents.  Finally, store the page number of the data page in firstPage and lastPage
attributes of the FileHdrPage.
*/


// When you have done all this unpin both pages and mark them as dirty.

const Status createHeapFile(const string fileName)
{
    File*       file;
    Status      status;
    FileHdrPage*    hdrPage;
    int         hdrPageNo;
    int         newPageNo;
    Page*       newPage;
    
    //check the fileName legth 
    
    // try to open the file. This should return an error
    status = db.openFile(fileName, file);
    if (status != OK)
    {
        // file doesn't exist. First create it and allocate
        // an empty header page and data page.
        status = db.createFile(fileName); //mignt be necessary to use the arrow ->
        if (status != OK){
            return status;
        }
        status = db.openFile(fileName, file);
        if (status != OK) {
            return status; // DOUBLE CHECK
        }

        status = bufMgr->allocPage(file, hdrPageNo, newPage);
        if (status != OK){
            return status;
        }

        hdrPage = (FileHdrPage *)newPage;
        strcpy(hdrPage->fileName, fileName.c_str());
    
        status = bufMgr->allocPage(file, newPageNo, newPage);
        if (status != OK){
            return status;
        }
        newPage->init(newPageNo); 
        hdrPage -> firstPage = newPageNo;
        hdrPage -> lastPage = newPageNo;
        hdrPage -> pageCnt = 1;
        hdrPage -> recCnt = 0;      
        
        status = bufMgr->unPinPage(file, hdrPageNo, true);
        if (status != OK){
            return status;
        }
        
        status = bufMgr->unPinPage(file, newPageNo, true);
        if (status != OK){
            return status;
        }
        status = db.closeFile(file);
        if (status != OK) {
            return status; // DOUBLE CHECK
        }
        return OK;
    }
    return (FILEEXISTS);
}

// routine to destroy a heapfile
const Status destroyHeapFile(const string fileName)
{
    return (db.destroyFile (fileName));
}


// constructor opens the underlying file
/*As discussed above, a heap file consists of one file header page and 1 or more data pages. The HeapFile class provides a set of methods to manipulate heap files including adding and deleting records and scanning all records in a file. Creating an instance of the heapFile class opens the heap file and reads the file header page and the first data page into the buffer pool.

This method first opens the appropriate file by calling db->openFile() (do not forget to save the File* returned in the filePtr data member). Next, it reads and pins the header page for the file in the buffer pool, initializing the private data members headerPage, headerPageNo, and hdrDirtyFlag. You might be wondering how you get the page number of the header page. This is what file->getFirstPage() is used for (see description of the I/O layer)! Finally, read and pin the first page of the file into the buffer pool, initializing the values of curPage, curPageNo, and curDirtyFlag appropriately. Set curRec to NULLRID.
*/
HeapFile::HeapFile(const string & fileName, Status& returnStatus)
{
    Status  status;
    Page*   pagePtr;

    cout << "opening file " << fileName << endl;

    // open the file and read in the header page and the first data page
    if ((status = db.openFile(fileName, filePtr)) == OK)
    {
        // Read in header page
        if ((status = filePtr->getFirstPage(headerPageNo)) != OK) {
            returnStatus = status;
            return;
        }
        if ((status = bufMgr->readPage(filePtr, headerPageNo, pagePtr)) != OK) {
            returnStatus = status;
            return;
        }
        headerPage = (FileHdrPage *) pagePtr;
        hdrDirtyFlag = false;

        // Read in first page
        status = bufMgr->readPage(filePtr, headerPage->firstPage, curPage);
        if (status != OK) {
            returnStatus = status;
            return;
        }
        curPageNo = headerPage->firstPage;
        curDirtyFlag = false;
        curRec = NULLRID;
    
    }
    else
    {
        cerr << "open of heap file failed\n";
        returnStatus = status;
        return;
    }
}


// the destructor closes the file
/*The destructor first unpins the header page and currently pinned data page and then calls db->closeFile
*/
HeapFile::~HeapFile()
{
    Status status;
    cout << "invoking heapfile destructor on file " << headerPage->fileName << endl;

    // see if there is a pinned data page. If so, unpin it 
    if (curPage != NULL)
    {
        status = bufMgr->unPinPage(filePtr, curPageNo, curDirtyFlag);
        curPage = NULL;
        curPageNo = 0;
        curDirtyFlag = false;
        if (status != OK) cerr << "error in unpin of date page\n";
    }
    
     // unpin the header page
    status = bufMgr->unPinPage(filePtr, headerPageNo, hdrDirtyFlag);
    if (status != OK) cerr << "error in unpin of header page\n";
    
    // status = bufMgr->flushFile(filePtr);  // make sure all pages of the file are flushed to disk
    // if (status != OK) cerr << "error in flushFile call\n";
    // before close the file
    status = db.closeFile(filePtr);
    if (status != OK)
    {
        cerr << "error in closefile call\n";
        Error e;
        e.print (status);
    }
}


/*Returns the number of records currently in the file (as found in the header page for the file).
*/
const int HeapFile::getRecCnt() const
{
  return headerPage->recCnt;
}


// retrieve an arbitrary record from a file.
// if record is not on the currently pinned page, the current page
// is unpinned and the required page is read into the buffer pool
// and pinned.  returns a pointer to the record via the rec parameter
/*
This method returns a record (via the rec structure) given the RID of the record. The private data members
curPage and curPageNo should be used to keep track of the current data page pinned in the buffer pool.
If the desired record is on the currently pinned page, simply invoke curPage->getRecord(rid, rec) 
to get the record.  Otherwise, you need to unpin the currently pinned page (assuming a page is pinned) 
and use the pageNo field of the RID to read the page into the buffer pool.
*/
//TODO
const Status HeapFile::getRecord(const RID & rid, Record & rec)
{
    Status status;
//    cout<< "getRecord. record (" << rid.pageNo << "." << rid.slotNo << ")" << endl;
    if (rid.pageNo == curPageNo){ 
        status = curPage-> getRecord(rid, rec);
        if (status != OK) {
            return status;
        }
        curRec = rid;
        return OK;
    }
    else {
        if ((status = bufMgr -> unPinPage (filePtr, curPageNo, false)) != OK){
            return status;
        } 
        curPageNo = rid.pageNo; 
        if ((status = bufMgr -> readPage (filePtr, curPageNo, curPage)) != OK){
            return status;
        }
        
        status =  curPage -> getRecord(rid, rec);
        if (status != OK) {
            return status;
        }
        curRec = rid;
        return OK;
    }
}


/*First note that the protected data members curPage, curPageNo, curRec, and curDirtyFlag should be used to implement the scan mechanism.

The other private data members are used to implement conditional or filtered scans. length is the size of the field on which predicate is applied and offset is its position within the record (we consider fixed length attributes only). The type of the attribute can be STRING, INTEGER or FLOAT and is defined in heapFile.h  Similarly all ordinary comparison operators (as defined in heapFile.h) must be supported. The value to be compared against is stored in binary form and is pointed to by filter
i*/

/*
Initializes the data members of the object and then opens the appropriate heapfile by calling the HeapFile constructor with the name of the file. The status of all these operations is indicated via the status parameter.

For those of you new to C++, since HeapFileScan is derived from HeapFile, the constructor for the HeapFile class is invoked before the HeapFileScan constructor is invoked.

Shuts down the scan by calling endScan().  After the HeapFileScan destructor is invoked, the HeapFile destructor will be automatically invoked
*/
HeapFileScan::HeapFileScan(const string & name,
               Status & status) : HeapFile(name, status)
{
    filter = NULL;
}


/*This method initiates a scan over a file. If filter == NULL, an unconditional scan is performed meaning that the scan will return all the records in the file. Otherwise, the data members of the HeapFileScan object are initialized with the parameters to the method.
*/
const Status HeapFileScan::startScan(const int offset_,
                     const int length_,
                     const Datatype type_, 
                     const char* filter_,
                     const Operator op_)
{
    if (!filter_) {                        // no filtering requested
        filter = NULL;
        return OK;
    }
    
    if ((offset_ < 0 || length_ < 1) ||
        ((type_ != STRING && type_ != INTEGER && type_ != FLOAT)) ||
        (type_ == INTEGER && length_ != sizeof(int)
         ||( type_ == FLOAT && length_ != sizeof(float))) ||
        (op_ != LT && op_ != LTE && op_ != EQ && op_ != GTE && op_ != GT && op_ != NE))
    {
        return BADSCANPARM;
    }

    offset = offset_;
    length = length_;
    type = type_;
    filter = filter_;
    op = op_;

    return OK;
}


/* This method terminates a scan over a file but does not delete the scan object.  This will allow the scan object to be reused for another scan.
*/
const Status HeapFileScan::endScan()
{
    Status status;
    // generally must unpin last page of the scan
    if (curPage != NULL)
    {
        status = bufMgr->unPinPage(filePtr, curPageNo, curDirtyFlag);
        curPage = NULL;
        curPageNo = 0;
        curDirtyFlag = false;
        return status;
    }
    return OK;
}


HeapFileScan::~HeapFileScan()
{
    endScan();
}


/* Saves the current position of the scan by preserving the values of curPageNo and curRec in the private data members markedPageNo and markedRec, respectively.
*/
const Status HeapFileScan::markScan()
{
    // make a snapshot of the state of the scan
    markedPageNo = curPageNo;
    markedRec = curRec;
    return OK;
}


/* Resets the position of the scan to the position when the scan was last marked by restoring the values of curPageNo and curRec from markedPageNo and markedRec, respectively. Unless the page number of the currently pinned page is the same as the marked page number, unpin the currently pinned page, then read markedPageNo from disk and set curPageNo, curPage, curRec, and curDirtyFlag appropriately.
*/
const Status HeapFileScan::resetScan()
{
    Status status;
    if (markedPageNo != curPageNo) 
    {
        if (curPage != NULL)
        {
            status = bufMgr->unPinPage(filePtr, curPageNo, curDirtyFlag);
            if (status != OK) return status;
        }
        // restore curPageNo and curRec values
        curPageNo = markedPageNo;
        curRec = markedRec;
        // then read the page
        status = bufMgr->readPage(filePtr, curPageNo, curPage);
        if (status != OK) return status;
        curDirtyFlag = false; // it will be clean
    }
    else curRec = markedRec;
    return OK;
}


/* Returns (via the outRid parameter) the RID of the next record that satisfies the scan predicate. The basic idea is to scan the file one page at a time. For each page, use the firstRecord() and nextRecord() methods of the Page class to get the rids of all the records on the page. Convert the rid to a pointer to the record data and invoke matchRec() to determine if record satisfies the filter associated with the scan. If so, store the rid in curRec and return curRec. To make things fast, keep the current page pinned until all the records on the page have been processed. Then continue with the next page in the file.  Since the HeapFileScan class is derived from the HeapFile class it also has all the methods of the HeapFile class as well. Returns OK if no errors occurred. Otherwise, return the error code of the first error that occurred.
*/
//TODO
const Status HeapFileScan::scanNext(RID& outRid)
{
    Status  status = OK;
    RID     nextRid;
    RID     tmpRid;
    int     nextPageNo;
    Record      rec;
    bool    found = false;
    
    
/*    status = bufMgr->readPage(filePtr, curPageNo, curPage);
    if (status != OK){
        return status;
    }
  */ 
    tmpRid = curRec;

    while (!found){
        status = curPage->nextRecord(tmpRid, nextRid);
        if (status == ENDOFPAGE){

            status = curPage->getNextPage(nextPageNo);
            if (status != OK){
                return status;
            } else if (nextPageNo == -1) {
                return FILEEOF;
            }
            
            status = bufMgr->unPinPage(filePtr, curPageNo, curDirtyFlag);
            if (status != OK){
                return status;
            }

            status = bufMgr->readPage(filePtr, nextPageNo, curPage);
            if (status != OK){
                return status;
            }
            curPageNo = nextPageNo;
            curDirtyFlag = false;

            status = curPage->firstRecord(nextRid);
            if (status != OK){
                return status;
            } 
        }
        tmpRid = nextRid;
        status = curPage->getRecord(tmpRid, rec);
        if (status != OK){
            return status;
        } 
//        curRec = tmpRid;
        if (matchRec(rec)){
            curRec = tmpRid;
            outRid = curRec;
            found = true;
        }
    }

    return OK;
   
}


// returns pointer to the current record.  page is left pinned
// and the scan logic is required to unpin the page 
/* Returns (via the rec parameter) the record whose rid is stored in curRec. The page containing the record should already be pinned in the buffer pool (by a preceding scanNext() call). If not, return BADPAGENO. A pointer to the pinned page can be found in curPage. Just invoke Page::getRecord() on this page and return its status value.
*/
const Status HeapFileScan::getRecord(Record & rec)
{
    return curPage->getRecord(curRec, rec);
}


// delete record from file. 
/* Deletes the record with RID whose rid is stored in curRec from the file by calling Page::deleteRecord. The record must be a record on the "current" page of the scan. Returns BADPAGENO if the page number of the record (i.e. curRec.pageNo) does not match curPageNo, otherwise OK.
*/
const Status HeapFileScan::deleteRecord()
{
    Status status;

    // delete the "current" record from the page
    status = curPage->deleteRecord(curRec);
    curDirtyFlag = true;

    // reduce count of number of records in the file
    headerPage->recCnt--;
    hdrDirtyFlag = true; 
    return status;
}


// mark current page of scan dirty
/* Marks the current page of the scan dirty by setting the dirtyFlag. The dirtyFlag should be reset every time a page is pinned. Make sure that when you unpin a page in the buffer pool, that you pass dirtyFlag as a parameter to the unpin call. Returns OK if no errors. The page containing the record should already be pinned in the buffer pool.
*/
const Status HeapFileScan::markDirty()
{
    curDirtyFlag = true;
    return OK;
}


/* This private method determines whether the record rec satisfies the predicate associated with the scan. It takes care of attributes not being aligned properly. Returns true if the record satisfies the predicate, false otherwise. We will provide this method for you.
*/
const bool HeapFileScan::matchRec(const Record & rec) const
{
    // no filtering requested
    if (!filter) return true;

    // see if offset + length is beyond end of record
    // maybe this should be an error???
    if ((offset + length -1 ) >= rec.length)
    return false;

    float diff = 0;                       // < 0 if attr < fltr
    switch(type) {

    case INTEGER:
        int iattr, ifltr;                 // word-alignment problem possible
        memcpy(&iattr,
               (char *)rec.data + offset,
               length);
        memcpy(&ifltr,
               filter,
               length);
        diff = iattr - ifltr;
        break;

    case FLOAT:
        float fattr, ffltr;               // word-alignment problem possible
        memcpy(&fattr,
               (char *)rec.data + offset,
               length);
        memcpy(&ffltr,
               filter,
               length);
        diff = fattr - ffltr;
        break;

    case STRING:
        diff = strncmp((char *)rec.data + offset,
                       filter,
                       length);
        break;
    }

    switch(op) {
    case LT:  if (diff < 0.0) return true; break;
    case LTE: if (diff <= 0.0) return true; break;
    case EQ:  if (diff == 0.0) return true; break;
    case GTE: if (diff >= 0.0) return true; break;
    case GT:  if (diff > 0.0) return true; break;
    case NE:  if (diff != 0.0) return true; break;
    }

    return false;
}


/* Again this constructor will get invoked after the HeapFile constructor is invoked since InsertFileScan is derived from the HeapFile class. See the test program for examples of how this constructor is used.
*/
InsertFileScan::InsertFileScan(const string & name,
                               Status & status) : HeapFile(name, status)
{
  //Do nothing. Heapfile constructor will bread the header page and the first
  // data page of the file into the buffer pool
}


/* Unpins the last page of the scan and then returns.  The HeapFile destructor will be automatically invoked
*/
InsertFileScan::~InsertFileScan()
{
    Status status;
    // unpin last page of the scan
    if (curPage != NULL)
    {
        status = bufMgr->unPinPage(filePtr, curPageNo, true);
        curPage = NULL;
        curPageNo = 0;
        if (status != OK) cerr << "error in unpin of data page\n";
    }
}


/* 
 * Inserts the record described by rec into the file returning the RID of the inserted record in outRid.
 */
// Insert a record into the file
// TODO UNPIN??
const Status InsertFileScan::insertRecord(const Record & rec, RID& outRid)
{
    Page *  newPage; 
    int     newPageNo;
    Status  status; // unpinstatus;
    RID     rid;

    // check for very large records
    if ((unsigned int) rec.length > PAGESIZE-DPFIXED)
    {
        // will never fit on a page, so don't even bother looking
        return INVALIDRECLEN;
    }
   
    if (headerPage->lastPage != curPageNo) {
        status = bufMgr->unPinPage(filePtr, headerPage->lastPage, curDirtyFlag);
        if (status != OK){
            return status;
        }
        
        if ((status = bufMgr->readPage(filePtr, headerPage->lastPage, curPage)) != OK) {
            return status;
        }
        curPageNo = headerPage->lastPage;
        curDirtyFlag = false;
    }
 
    status = curPage->insertRecord(rec, rid);

    if (status == NOSPACE) {
        // Create new page
        // Ensure page is now last page of heapfile
        status = bufMgr->allocPage(filePtr, newPageNo, newPage);
        if (status != OK){
            return status;
        }
        newPage->init(newPageNo);

        curPage->setNextPage(newPageNo);
        status = bufMgr->unPinPage(filePtr, headerPage->lastPage, curDirtyFlag);
        if (status != OK){
            return status;
        }
        curPage = newPage;
        curPageNo = newPageNo;
        headerPage->lastPage = newPageNo;
        headerPage->pageCnt++;
      
        status = newPage->insertRecord(rec, rid);
        // In theory, should always be OK
        if (status != OK) {
            return status;
        }
    }
    curDirtyFlag = true;
    // Unpin Header?
    headerPage->recCnt++;
    hdrDirtyFlag = true;
    outRid = rid;
    curRec = rid;
    return OK;
}
